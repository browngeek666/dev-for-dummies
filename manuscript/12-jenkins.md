# Jenkins

It all started by a visionary developer, Kohsuke Kawaguchi, in 2004 while he was working for Sun Microsystems. He had a hobby project he named Hudson. The goal was to create a platform that can be used to execute scheduled tasks. Over the years Hudson evolved and was adopted by an ever increasing number of teams within Sun. Around 2008 the value behind Hudson was widelly recognized and Kohsuke started working full time on its development and support. Around 2010 it was clear that Hudson was the leading solution for continuous integration. It owned around 70% of the market.

2009 marks the beginning of the end of Hudson. Oracle purchased Sun and tensions arose between Hudson's developer community and Oracle. The community wanted to keep the project open while Oracle claimed Hudson's trademark. Oracle wanted more control over the development process which was in stark contrast with community (led by Kohsuke) goal of keeping it open. The result of the conflict was a Hudson's fork called Jenkins. Hudson ended up under Oracle's umbrella while Jenkins continued being an open source project. Today, Hudson hardly even exists while Jenkins continues being undisputed market leader in continuous integration as well as continuous delivery and deployment.

Platform based on plugins ecosystem allowed Jenkins to strive. The community grew at a rapid pace converting Jenkins in one of the biggest open source projects. Today, with more than 1200 plugins, there is hardly anything we might need to do that is not covered. Need to checkout the code from your GitHub repository? There is a plugin (or two) just for that. Need to build your project with Gradle? Simply choose one of the Gradle plugins that suits your needs.

So, what is Jenkins? The answer to that question comes in two parts. To understand Jenkins today, we need to understand how it was yesterday.

## The World Before Jenkins Pipeline

In a nutshell, Jenkins allows us to schedule jobs. We can specify a time, a frequency, or external triggers that will execute a predefined set of tasks. Initially, a job would be a single task that, for example, builds an application, runs tests, or performs software deployment. A complex process would consists of a set of interconnected jobs. The first job would trigger the second, the second would trigger the third, all the way until the whole process is executed. The definition of those jobs would be created using Jenkins' UI. We would create a new job, select a plugin that, for example, checks out the code from our repository and fill in a few fields. As a result, the job would check out the code when Jenkins detects a new commit to the repository.

Time goes on and what was good yesterday is not necessarily just as good today. Jenkins' ability to create and connect as many jobs into a single process and its reliance on UI are some of the features that made it so popular. However, those same features may not fulfil the needs the software industry has today. In general, developer tools are moving towards using code for everything. For an engineer, it is easier to specify what should happen and when through code than using an UI. Code can be versioned and reviewed. It allows us to be more precise in describing our expectations. Finally, a code will be able to define in a relatively easy way a set of complex operations that would be quite challenging to create through UI. Further on, with the move towards self-sufficient autonomous teams came the need to be able to define jobs in a decentralized manner. We needed a way to store jobs related to an application in the same repository where its code is. Those needs are in stark contrast with Jenkins which assumes that everything is defined in one central location and controlled by its UI.

Processes we're trying to automate today are often much more complex than those we aimed for in the past. While, before, we would be happy having Jenkins checkout the code, run some tests, and build the application, now we need it to run vastly bigger amounts of tests in parallel, deploy to production, and even be triggered by out monitoring system when things go wrong. As the result, the average number of interconnected jobs increased and, with them, the complexity to define and maintain them. We needed a unique view for the whole process.

The need for defining processes through code and as a single flow, resulted in Jenkins Pipeline.
